/*
** 
** Copyright (C) 2019 Ambrose Gihan de Silva
** 
** Redistribution and use in source and binary forms, with or without 
** modification, are permitted provided that the following conditions are met:
** 
** 1. Redistributions of source code must retain the above copyright notice, this 
** list of conditions and the following disclaimer.
** 
** 2. Redistributions in binary form must reproduce the above copyright notice, 
** this list of conditions and the following disclaimer in the documentation 
** and/or other materials provided with the distribution.
** 
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR 
** ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
**  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
**  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
**  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
**  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**  
 */
package com.shinkusoft.javapuzzle2;

import com.shinkusoft.javapuzzle2.JavaPuzzle2.PuzzleToolsSolverMethod;
import javax.swing.SpinnerNumberModel;

/**
 *
 * @author Gihan
 */
public class ToolsSolverDialog extends javax.swing.JDialog
{

    /**
     * Creates new form ToolsDialog
     */
    public ToolsSolverDialog(PuzzleFrame parent, boolean modal)
    {
        super(parent, modal);
        initComponents();
        this.frame = parent;
    }
    
    private int getMaxSolverMovesValue()
    {
        PuzzleToolsConfig toolsConfig = JavaPuzzle2.getToolsConfigData();
        assert(toolsConfig != null);
        int result = toolsConfig.getMaxSolverTreeSize();
        SpinnerNumberModel model = (SpinnerNumberModel)maxTreeSizeValue.getModel();
        result = model.getNumber().intValue();
        return result;
    }
    
    private PuzzleToolsSolverMethod getCurrentSolverMethodValue()
    {
        PuzzleToolsConfig toolsConfig = JavaPuzzle2.getToolsConfigData();
        assert(toolsConfig != null);
        PuzzleToolsSolverMethod result = toolsConfig.getCurrentSolverMethod();
        
        int selectedMethodIndex = SolverMethodValue.getSelectedIndex();
        if (selectedMethodIndex != -1)
        {
            assert(selectedMethodIndex < JavaPuzzle2.PuzzleToolsSolverMethod.MAX_NUM_SUPPORTED_SOLVER_METHODS.getIntValue());
            result = JavaPuzzle2.PuzzleToolsSolverMethod.getValue(selectedMethodIndex);
        }
        
        return result;
    }
    
    //TODO test this works ok!
    private void ApplyChanges()
    {
        PuzzleToolsConfig toolsConfig = JavaPuzzle2.getToolsConfigData();
        
        toolsConfig.setCurrentSolverMethod(getCurrentSolverMethodValue());
        
        int maxSolverMoves = getMaxSolverMovesValue();
        toolsConfig.setMaxSolverTreeSize(maxSolverMoves);
        
        toolsConfig.setSolverUpdatesGUI(SolverUpdatesGUIcheckBox.isSelected());
        frame.updateSolverRelatedInfo(PuzzleFrame.SolverInfoDialogUpdateMode.SOLVER_MAX_MOVES);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        SolverUpdatesGUIcheckBox = new javax.swing.JCheckBox();
        numMovesLimitLabel = new javax.swing.JLabel();
        SolverAlgorithmLabel = new javax.swing.JLabel();
        SolverMethodValue = new javax.swing.JComboBox<>();
        SolverMovesInHistoryCheckBox = new javax.swing.JCheckBox();
        ApplyButton = new javax.swing.JButton();
        OKButton = new javax.swing.JButton();
        CancelButton = new javax.swing.JButton();
        maxTreeSizeValue = new javax.swing.JSpinner();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Solver Configuration");
        setModal(true);

        SolverUpdatesGUIcheckBox.setSelected(true);
        SolverUpdatesGUIcheckBox.setText("update GUI for each move");
        SolverUpdatesGUIcheckBox.setEnabled(false);

        numMovesLimitLabel.setText("Maximum Number of moves allowable:");

        SolverAlgorithmLabel.setText("Solver method: ");

        SolverMethodValue.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Pure greedy search", "Uniform Cost search" }));
        SolverMethodValue.setSelectedIndex(1);

        SolverMovesInHistoryCheckBox.setSelected(true);
        SolverMovesInHistoryCheckBox.setText("Add Solver moves to history");
        SolverMovesInHistoryCheckBox.setEnabled(false);

        ApplyButton.setText("Apply");
        ApplyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ApplyButtonActionPerformed(evt);
            }
        });

        OKButton.setText("OK");
        OKButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OKButtonActionPerformed(evt);
            }
        });

        CancelButton.setText("Cancel");
        CancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CancelButtonActionPerformed(evt);
            }
        });

        maxTreeSizeValue.setModel(new javax.swing.SpinnerNumberModel(10000, 100, 500000, 1));
        maxTreeSizeValue.setValue(10000);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(SolverMethodValue, javax.swing.GroupLayout.Alignment.TRAILING, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(SolverUpdatesGUIcheckBox)
                            .addComponent(SolverAlgorithmLabel)
                            .addComponent(SolverMovesInHistoryCheckBox)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(numMovesLimitLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(maxTreeSizeValue, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(layout.createSequentialGroup()
                .addGap(155, 155, 155)
                .addComponent(ApplyButton)
                .addGap(18, 18, 18)
                .addComponent(OKButton)
                .addGap(18, 18, 18)
                .addComponent(CancelButton)
                .addContainerGap(14, Short.MAX_VALUE))
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {ApplyButton, CancelButton, OKButton});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(SolverUpdatesGUIcheckBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numMovesLimitLabel)
                    .addComponent(maxTreeSizeValue, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(SolverAlgorithmLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(SolverMethodValue, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(SolverMovesInHistoryCheckBox)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ApplyButton)
                    .addComponent(OKButton)
                    .addComponent(CancelButton))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {ApplyButton, CancelButton, OKButton});

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ApplyButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_ApplyButtonActionPerformed
    {//GEN-HEADEREND:event_ApplyButtonActionPerformed
        ApplyChanges();
    }//GEN-LAST:event_ApplyButtonActionPerformed

    private void OKButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_OKButtonActionPerformed
    {//GEN-HEADEREND:event_OKButtonActionPerformed

        ApplyChanges();
        setVisible(false);
    }//GEN-LAST:event_OKButtonActionPerformed

    private void CancelButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_CancelButtonActionPerformed
    {//GEN-HEADEREND:event_CancelButtonActionPerformed
        setVisible(false);
    }//GEN-LAST:event_CancelButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try
        {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels())
            {
                if ("Nimbus".equals(info.getName()))
                {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex)
        {
            java.util.logging.Logger.getLogger(ToolsSolverDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex)
        {
            java.util.logging.Logger.getLogger(ToolsSolverDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex)
        {
            java.util.logging.Logger.getLogger(ToolsSolverDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex)
        {
            java.util.logging.Logger.getLogger(ToolsSolverDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the dialog */
//        java.awt.EventQueue.invokeLater(new Runnable()
//        {
//            public void run()
//            {
//                if (dialog == null)
//                {
//                    dialog = new ToolsSolverDialog(new javax.swing.JFrame(), true);
//                    dialog.setVisible(true);
//                }
//            }
//        });
    }
    
    final private PuzzleFrame frame;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ApplyButton;
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton OKButton;
    private javax.swing.JLabel SolverAlgorithmLabel;
    protected javax.swing.JComboBox<String> SolverMethodValue;
    private javax.swing.JCheckBox SolverMovesInHistoryCheckBox;
    protected javax.swing.JCheckBox SolverUpdatesGUIcheckBox;
    private javax.swing.JSpinner maxTreeSizeValue;
    private javax.swing.JLabel numMovesLimitLabel;
    // End of variables declaration//GEN-END:variables

}
